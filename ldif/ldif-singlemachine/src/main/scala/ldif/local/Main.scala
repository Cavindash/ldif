package ldif.local

import datasources.dump.DumpExecutor
import runtime._
import impl._
import ldif.modules.silk.SilkModule
import ldif.datasources.dump.{DumpModule, DumpConfig}
import ldif.modules.silk.local.SilkLocalExecutor
import de.fuberlin.wiwiss.ldif.{EntityBuilderModule, EntityBuilderConfig}
import de.fuberlin.wiwiss.r2r._
import ldif.modules.r2r.local.R2RLocalExecutor
import ldif.modules.r2r._
import ldif.entity.EntityDescription
import de.fuberlin.wiwiss.ldif.local.EntityBuilderExecutor
import java.util.Properties
import java.io._
import java.util.logging.Logger
import util.StringPool
import ldif.util.Consts

object Main
{
  private val log = Logger.getLogger(getClass.getName)
  // Object to store all kinds of configuration data
  private var configParameters: ConfigParameters = null

  def main(args : Array[String])
  {
    var debug = false
    if(args.length<1) {
      println("No configuration file given.")
      System.exit(1)
    }
    else if(args.length>=2 && args(0)=="--debug")
      debug = true

    //val configUrl = getClass.getClassLoader.getResource("ldif/local/example/test2/config.xml")
    //val configFile = new File(configUrl.toString.stripPrefix("file:"))
    val configFile = new File(args(args.length-1))
    runIntegrationFlow(configFile, debug)
  }

  private def setupQuadReader(_clonedR2rReader: QuadReader): QuadReader = {
    var clonedR2rReader: QuadReader = _clonedR2rReader
    if (clonedR2rReader.isInstanceOf[FileQuadReader]) {
      clonedR2rReader.asInstanceOf[FileQuadReader].close()
      clonedR2rReader = new FileQuadReader(clonedR2rReader.asInstanceOf[FileQuadReader].inputFile)
    }
    clonedR2rReader
  }

  def runIntegrationFlow(configFile: File, debugMode: Boolean) {
    stopWatch.getTimeSpanInSeconds
    val config: LdifConfiguration = loadConfigFile(configFile)

    // Setup config properties file
    configProperties.loadPropertyFile(config.propertiesFile)

     // Validate configuration
    val fail = ConfigValidator.validateConfiguration(config)
    if(fail) {
      println("!- Validation phase failed")
      sys.exit(1)
    } else {
      println("-- Validation phase succeeded in " + stopWatch.getTimeSpanInSeconds + "s")
    }

    // Quads that are not used in the integration flow, but should still be output
    val otherQuadsFile = File.createTempFile("ldif-other-quads", ".bin")

    // Quads that contain external sameAs links
    val sameAsQuadsFile = File.createTempFile("ldif-sameas-quads", ".bin")

    setupConfigParameters(otherQuadsFile, sameAsQuadsFile)

    val quadReaders = loadDump(config.sources)

    var r2rReader: QuadReader = executeMappingPhase(config, quadReaders)

    if(debugMode==true)
      r2rReader = writeDebugOutput("r2r", config.outputFile, r2rReader)

    var linkReader: QuadReader = executeLinkingPhase(config, r2rReader)

    if(debugMode==true)
      linkReader = writeDebugOutput("silk", config.outputFile, linkReader)

    configParameters.otherQuadsWriter.finish
    val otherQuadsReader = new FileQuadReader(otherQuadsFile)

    configParameters.sameAsWriter.finish
    val sameAsReader = new FileQuadReader(sameAsQuadsFile)

    val clonedR2rReader = setupQuadReader(r2rReader)

    val allQuads = new MultiQuadReader(clonedR2rReader, otherQuadsReader)
    val allSameAsLinks = new MultiQuadReader(linkReader, sameAsReader)

    var integratedReader: QuadReader = allQuads

    if(configProperties.getPropertyValue("rewriteURIs", "true").toLowerCase=="true")
      integratedReader = executeURITranslation(allQuads, allSameAsLinks, configParameters.configProperties)

    //OutputValidator.compare(cloneQuadQueue(integratedReader),new File(configFile.getParent+"/../results/all-mes.nt"))

    writeOutput(config, integratedReader)
  }



  def setupConfigParameters(outputFile: File, sameasFile: File) {
    var otherQuads: QuadWriter = new FileQuadWriter(outputFile)
    var sameAsQuads: QuadWriter = new FileQuadWriter(sameasFile)

    // Setup config parameters
    configParameters = ConfigParameters(configProperties, otherQuads, sameAsQuads)

    // Setup LocalNode (to pool strings etc.)
    LocalNode.reconfigure(configProperties)
  }

  private def executeMappingPhase(config: LdifConfiguration, quadReaders: Seq[QuadReader]): QuadReader = {
    val r2rReader: QuadReader = mapQuads(config.mappingFile, quadReaders)
    println("Time needed to map data: " + stopWatch.getTimeSpanInSeconds + "s")

    r2rReader
  }

  private def executeLinkingPhase(config: LdifConfiguration, r2rReader: QuadReader): QuadReader = {
    val linkReader = generateLinks(config.linkSpecDir, r2rReader)
    println("Time needed to link data: " + stopWatch.getTimeSpanInSeconds + "s")
    println("Number of links generated by silk: " + linkReader.size)
    linkReader
  }

  private def loadConfigFile(configFile: File): LdifConfiguration = {
    val config = LdifConfiguration.load(configFile)
    println("Time needed to load config file: " + stopWatch.getTimeSpanInSeconds + "s")
    config
  }

  private def executeURITranslation(inputQuadReader: QuadReader, linkReader: QuadReader, configProperties: ConfigProperties): QuadReader = {
    val integratedReader = URITranslator.translateQuads(inputQuadReader, linkReader, configProperties)

    println("Time needed to translate URIs: " + stopWatch.getTimeSpanInSeconds + "s")
    integratedReader
  }

  def runIntegrationFlow(configFile: File) {
    runIntegrationFlow(configFile, false)
  }

  /**
   * Loads the dump files.
   */
  def loadDump(sources : Traversable[String]) : Seq[QuadReader] =
  {
    val dumpModule = new DumpModule(new DumpConfig(sources))
    val dumpExecutor = new DumpExecutor

    val quadQueues = for (i <- 1 to dumpModule.tasks.size) yield new BlockingQuadQueue(Consts.DEFAULT_QUAD_QUEUE_CAPACITY)


      for((dumpTask, writer) <- dumpModule.tasks.toList zip quadQueues){
        runInBackground
          {
            dumpExecutor.execute(dumpTask, null, writer)
          }
      }
    quadQueues.toSeq
  }


  /**
   * Transforms the Quads
   */
  private def mapQuads(mappingFile: File, readers: Seq[QuadReader]) : QuadReader = {
    val repository = new Repository(new FileOrURISource(mappingFile))
    val executor = new R2RLocalExecutor
    val config = new R2RConfig(repository)
    val module = new R2RModule(config)

    val entityDescriptions = for(task <- module.tasks) yield task.mapping.entityDescription
    val entityReaders = buildEntities(readers, entityDescriptions.toSeq, configParameters)
    StringPool.reset
    println("Time needed to load dump and build entities for mapping phase: " + stopWatch.getTimeSpanInSeconds + "s")
    //println("Number of triples after loading the dump: " + (quadReaders.foldLeft(0)(_ + _.totalSize)))

    val outputFile = File.createTempFile("ldif-mapped-quads", ".bin")
    outputFile.deleteOnExit
    val writer = new FileQuadWriter(outputFile)

    //runInBackground
    {
      for((r2rTask, reader) <- module.tasks.toList zip entityReaders)
        executor.execute(r2rTask, Seq(reader), writer)
    }
    writer.finish
    new FileQuadReader(outputFile)
  }

  /**
   * Generates links.
   */
  private def generateLinks(linkSpecDir : File, reader : QuadReader) : QuadReader =
  {
    val silkModule = SilkModule.load(linkSpecDir)
    val silkExecutor = new SilkLocalExecutor

    val entityDescriptions = silkModule.tasks.toIndexedSeq.map(silkExecutor.input).flatMap{ case StaticEntityFormat(ed) => ed }
    val entityReaders = buildEntities(Seq(reader), entityDescriptions, ConfigParameters(configProperties))
    StringPool.reset
    println("Time needed to build entities for linking phase: " + stopWatch.getTimeSpanInSeconds + "s")

    val outputQueue = new QuadQueue

    //runInBackground
    {
      for((silkTask, readers) <- silkModule.tasks.toList zip entityReaders.grouped(2).toList)
      {
        silkExecutor.execute(silkTask, readers, outputQueue)
      }
    }

    outputQueue
  }

  /**
   * Build Entities.
   */
  private def buildEntities(readers : Seq[QuadReader], entityDescriptions : Seq[EntityDescription], configParameters: ConfigParameters) : Seq[EntityReader] =
  {
    var entityWriters: Seq[EntityWriter] = null
    val entityQueues = entityDescriptions.map(new EntityQueue(_))
    val fileEntityQueues = for(eD <- entityDescriptions) yield {
      val file = File.createTempFile("ldif_entities", ".dat")
      file.deleteOnExit
      new FileEntityWriter(eD, file)
    }

    val inmemory = configParameters.configProperties.getPropertyValue("entityBuilderType", "in-memory")=="in-memory"

    //Because of memory problems circumvent with FileQuadQueue */
    if(inmemory)
      entityWriters = entityQueues
    else
      entityWriters = fileEntityQueues

    try
    {
      val entityBuilderConfig = new EntityBuilderConfig(entityDescriptions.toIndexedSeq)
      val entityBuilderModule = new EntityBuilderModule(entityBuilderConfig)
      val entityBuilderTask = entityBuilderModule.tasks.head
      val entityBuilderExecutor = new EntityBuilderExecutor(configParameters)

      entityBuilderExecutor.execute(entityBuilderTask, readers, entityWriters)
    } catch {
      case e: Throwable => {
        e.printStackTrace
        exit(2)
      }
    }

    if(inmemory)
      return entityQueues
    else
      return fileEntityQueues.map((entityWriter) => new FileEntityReader(entityWriter.entityDescription, entityWriter.inputFile))

  }

  /**
   * Evaluates an expression in the background.
   */
  private def runInBackground(function : => Unit) {
    val thread = new Thread {
      private val listener: FatalErrorListener = FatalErrorListener

      override def run() {
        try {
          function
        } catch {
          case e: Exception => listener.reportError(e)
        }
      }
    }
    thread.start()
  }

  //TODO we don't have an output module, yet...
  private def writeOutput(config: LdifConfiguration, reader : QuadReader)    {
    val writer = new FileWriter(config.outputFile)
    var count = 0
    val nqOutput = configParameters.configProperties.getPropertyValue("outputFormat", "nq").toLowerCase.equals("nq")

    while(reader.hasNext) {
      if(nqOutput)
        writer.write(reader.read().toNQuadFormat + " .\n")
      else
        writer.write(reader.read().toNTripleFormat + " .\n")
      count += 1
    }

    writer.close()
    println(count + " Quads written")
  }

  private def writeDebugOutput(phase: String, outputFile: File, reader: QuadReader): QuadReader = {
    val newOutputFile = new File(outputFile.getAbsolutePath + "." + phase)
    copyAndDumpQuadQueue(reader, newOutputFile.getAbsolutePath)
  }

  def copyAndDumpQuadQueue(quadQueue: QuadReader, outputFile: String): QuadReader = {
    val quadOutput = File.createTempFile("ldif-debug-quads", ".bin")
    quadOutput.deleteOnExit
    val writer = new FileQuadWriter(quadOutput)
    val quadWriter = new BufferedWriter(new FileWriter(outputFile))

    while(quadQueue.hasNext) {
      val next = quadQueue.read
      quadWriter.write(next.toNQuadFormat)
      quadWriter.write(" .\n")
      writer.write(next)
    }
    quadWriter.flush()
    quadWriter.close()
    writer.finish
    return new FileQuadReader(writer.outputFile)
  }
}

object stopWatch {
  private var lastTime = System.currentTimeMillis

  def getTimeSpanInSeconds(): Double = {
    val newTime = System.currentTimeMillis
    val span = newTime - lastTime
    lastTime = newTime
    span / 1000.0
  }
}

object configProperties extends ConfigProperties {
  private val log = Logger.getLogger(getClass.getName)

  override def loadPropertyFile(propertyFile: File) {
    properties = new Properties()
    if(propertyFile!=null)
      try {
        val stream = new BufferedInputStream(new FileInputStream(propertyFile));
        properties.load(stream);
        stream.close();
      } catch {
        case e: IOException => {
          log.severe("No property file found at: " + propertyFile.getAbsoluteFile)
          System.exit(1)
        }
      }
  }

  override def getPropertyValue(property: String): String = {
    properties.getProperty(property)
  }

  override def getPropertyValue(property: String, default: String): String = {
    properties.getProperty(property, default)
  }
}

object FatalErrorListener extends FatalErrorListener {
  def reportError(e: Exception) {
    e.printStackTrace
    System.exit(1)
  }
}

trait FatalErrorListener {
  def reportError(e: Exception)
}